<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[springboot练手项目遇到的那些坑]]></title>
    <url>%2F2019%2F07%2F04%2Fspringboot%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91%2F</url>
    <content type="text"><![CDATA[前言​ 上个月跟着视频做了一个社区项目，学习了spring、springboot、mybatis的用法，框架的使用方法还是蛮好理解的，在这过程中掌握的知识就单独写几篇博客来说明吧，这篇博文主要讲在这个项目中遇到的那些坑 aa 坑 使用的mysql数据库，并且将某些字段设置了默认值，但是通过Mybatis框架插入的时候，还是插入了null值，原来mybatis的insert方法是将所有字段强行全部插入。解决办法：在插入之前给对象赋初始值。 由于在github上的项目不能暴露给别人使用云的key和id，所以我们在application.properties的同级目录下copy一个新的文件叫application-production.properties在里面放置我们生产环境中使用的key和id。此文件只存在于生产环境上，不提交git 部署​ 我选择的服务器是centos7，记录一下服务器环境搭建的步骤 要安装的环境： git jdk maven mysql 部署步骤： yum update: 更新安装工具 yum install git git clone (源码地址) yum install maven:自动会装好jdk 2 重启Mysql:service mysqld restart 查看mysql是否启动·service mysqld status Mysql环境安装好之后用navicat无论如何也连接不上，该授权的授权了，防火墙也都关闭了，查询原因我用的是ucloud的云主机，需要在ucloud控制台中把3306端口开放。 创建数据库，之后在community目录下运行mvn flyway:migrate，集成flyway我之前做过总结。 mvn clean compile package:项目打包，在项目目录下执行 java -jar -Dspring.profiles.active=production target/community-0.0.1-SNAPSHOT.jar 发布项目 注意数据库大小写敏感问题 nohup java -jar -Dspring.profiles.active=production target/community-0.0.1-SNAPSHOT.jar &amp;:后台运行 不挂进程]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>spring</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kmp算法]]></title>
    <url>%2F2019%2F06%2F25%2Fkmp%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言​ 这两天因为一些原因接触了kmp字串符匹配算法，原理很好理解，就是代码实现费了一番周折，看了《数据结构》这本书有关kmp算法的内容，又看了网上给出的一些解决方案，发现还是书上的代码最简洁、最易理解。 一些定义​ s1s2…..sn：主串 ​ t1t2…..tn： 模式串 ​ j ：模式串指针 ​ i ：主串指针 ​ 失配 ：si != tj 原理​ bp字符串的朴素匹配算法：当模式失配时，我们需要把模式指针j移动到0，主串指针i移动到i-j+2处。 ​ kmp算法在此基础上进行改进，对于模式串来说，每个字符对应一个next值（所有next值组成一个next数组），当模式失配时，主串的指针i不变，模式串的指针j移动到next[j]所对应的位置处。优点在于，kmp算法减少了指针的移动次数。 ​ kmp算法的实质：结合下图进行说明 ​ 如上图所示，当失配情况发生时，模式串[1,7]是显然已经匹配完成的。假如1、2位置处的所代表字符与6、7位置所代表的字符相同，当失配之后进行指针移动时，我们可以直接将1,2,移动到6,7原先所在的位置，大大减少了比较次数，主串指针也无需回溯。模式串向右滑动的距离就取决于next[j](此时j==8)。接下来就是如何求解的问题。 实现​ 求模式串向右滑动的距离，换句话说就是当失配发生时，主串i指针所对应的的字符应当直接和模式串第k个字符相比较，k的值就是next[j],j是失配发生时模式串的指针位置。从上面的例子可以看出，求解k所对应的方程式为：t1t2tk-1 = tj-k+1tj-k+2…tj-1 。 ​ 由此引出求next数组定义： next[1] = 0，t1 != si时，下一步进行t1与si+1的比较 k=1时,next[j] = 1，即不存在相同子串，下一步进行t1与si的比较 next[j] = k，(k尽可能大)假如next数组已经求解完成，下面是kmp算法的实现： 1234567891011121314public static int kmp(char[] b, char[] c) &#123; //b是模式串，c是主串 int[] next = getNexts(b); int j = 1,i = 1; while (j &lt; b.length &amp;&amp; i &lt; c.length) &#123; if (j == 0 || b[j - 1] == c[i - 1]) &#123; i++;j++; &#125; else &#123; j = next[j - 1]; &#125; &#125; if (j &gt; b.length - 1) return i - b.length; return -1; &#125; ​ 由于数组是从0开始的，所以涉及的数组的计算都将下标减1。由上文的介绍，代码很容易理解。 求next数组的思想跟kmp算法的思想是相似的，实质上是字符串的自身匹配，只不过主串要从1下标开始，模式串要从0下标开始（仔细想想很好理解，因为需要后面的子串和前面的子串相匹配嘛），代码如下： 1234567891011public static int[] getNexts(char[] b) &#123; int[] next = new int[b.length]; int i = 1,j = 0; next[0] = 0; while (i &lt; b.length) &#123; if (j == 0 || b[i - 1] == b[j - 1]) &#123; i++;j++;next[i - 1] = j; &#125; else &#123;j = next[j - 1];&#125; &#125; return next; &#125; 还有改进的nextval数组，有空再说咯。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>kmp</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集成flyway对数据库进行版本控制]]></title>
    <url>%2F2019%2F06%2F20%2F%E9%9B%86%E6%88%90flyway%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E8%A1%8C%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前言​ flyway官网 是这样描述自己的产品的：flyway是数据库的版本控制工具，它可以使数据库迁移变得简单。对我这种个人学习者的人来说，第二点太重要了，如果我换了个电脑，在github上clone下来源代码，通过执行一条命令，数据库就全部建好了。Springboot如何集成flyway呢？如何使用呢？ 步骤1.在pom文件中添加plugin​ 示例如下： 1234567891011121314151617&lt;plugin&gt; &lt;groupId&gt;org.flywaydb&lt;/groupId&gt; &lt;artifactId&gt;flyway-maven-plugin&lt;/artifactId&gt; &lt;version&gt;5.2.4&lt;/version&gt; &lt;configuration&gt; &lt;url&gt;jdbc:mysql://localhost/community?serverTimezone=GMT&lt;/url&gt; &lt;user&gt;root&lt;/user&gt; &lt;password&gt;*****&lt;/password&gt; &lt;/configuration&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; ​ 根据自身情况对相关联数据库进行配置。 2.创建Migration文件 ​ 步骤很简单，唯一需要注意的点是：文件名必须是Vn(n递增)__(两个下划线)*.sql *里面就是一些描述性语言 文件里面的内容就是你对数据库做出的修改。 3.在终端执行命令 mvn flyway:migrate ​ 万事ok!]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>flyway</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis generator配置]]></title>
    <url>%2F2019%2F06%2F20%2Fmybatis-generator%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[前言​ 每次做完一些配置都会忘，都要回去看博客，mybatis-generator的配置算是比较麻烦的了，但是配好之后用起来很方便，什么mapper，xml、model一键生成，几乎也不用自己写sql语句，爽的飞起，所以必须记录一下。 ​ 官方文档 步骤​ 首先确保你已经在pom文件中添加了mybatis的相关依赖。 1.pom文件中添加plugin，在里面添加数据库相关驱动123456789101112&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/plugin&gt; ​ 我使用的是myssql数据库，所以添加的mysql的驱动 2. 在resources下，创建generatorConfig.xml文件3.配置generatorCofig.xml文件官网示例文件 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;context id="DB2Tables" targetRuntime="MyBatis3"&gt; &lt;plugin type="org.mybatis.generator.plugins.RowBoundsPlugin"&gt;&lt;/plugin&gt; &lt;jdbcConnection driverClass="com.mysql.cj.jdbc.Driver" connectionURL="jdbc:mysql://localhost/community?serverTimezone=GMT" userId="root" password="******"&gt; &lt;property name="nullCatalogMeansCurrent" value="true"/&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver &gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;javaModelGenerator targetPackage="cpsky.community.model" targetProject="src/main/java"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;sqlMapGenerator targetPackage="mapper" targetProject="src/main/resources"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/sqlMapGenerator&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="cpsky.community.mapper" targetProject="src/main/java"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/javaClientGenerator&gt; &lt;table tableName="user" domainObjectName="User" &gt;&lt;/table&gt; &lt;table tableName="question" domainObjectName="Question" &gt;&lt;/table&gt; &lt;table tableName="comment" domainObjectName="Comment"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; &lt;jdbcConnection&gt;填写你的数据库有关信息 &lt;javaModelGenerator&gt;生成java模型（配好路径） &lt;sqlMapperGenerator&gt;生成mapper.xml文件（可以修改生成方式 如注释等） 详见 &lt;javaClientGenerator&gt;生成mapper层 &lt;table&gt;对应数据库的表 4.配置跟springboot相关联官网说明 启动类添加@MapperScan(mapper层路径如com.***.mapper) application.properties添加mybatis.mapper-locations=classpath:mapper/*.xml application.properties添加mybatis.type-aliases-package=com.example.domain.model 5.在终端运行命令 mvn -Dmybatis.generator.overwrite=true mybatis-generator:generate ​ overwrite默认覆盖原先已经存在的文件 6.自定义查询语句​ 因为overwirte=true 会覆盖原文件，所以要新建.xml文件和对应的mapper接口。举个例子： 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="cpsky.community.mapper.CommentExtMapper"&gt; &lt;resultMap id="BaseResultMap" type="cpsky.community.model.Comment"&gt; &lt;!-- WARNING - @mbg.generated This element is automatically generated by MyBatis Generator, do not modify. This element was generated on Sat Jun 08 11:39:52 CST 2019. --&gt; &lt;id column="id" jdbcType="BIGINT" property="id"/&gt; &lt;result column="parent_id" jdbcType="BIGINT" property="parentId"/&gt; &lt;result column="type" jdbcType="INTEGER" property="type"/&gt; &lt;result column="commentator" jdbcType="BIGINT" property="commentator"/&gt; &lt;result column="gmt_create" jdbcType="BIGINT" property="gmtCreate"/&gt; &lt;result column="gmt_modified" jdbcType="BIGINT" property="gmtModified"/&gt; &lt;result column="like_count" jdbcType="BIGINT" property="likeCount"/&gt; &lt;result column="content" jdbcType="VARCHAR" property="content"/&gt; &lt;result column="comment_count" jdbcType="INTEGER" property="commentCount"/&gt; &lt;/resultMap&gt; &lt;update id="incCommentCount" parameterType="cpsky.community.model.Comment"&gt; update COMMENT set comment_count = comment_count + #&#123;commentCount,jdbcType=INTEGER&#125; where id = #&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; ​ 要修改的有namespace ，以及curd语句，语法就是mybatis的语法辣，对应的Mapper接口长这个样子： 123public interface CommentExtMapper &#123; int incCommentCount(Comment comment);&#125;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划算法学习]]></title>
    <url>%2F2019%2F06%2F18%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前言​ 这几天做了一个leetcode的题，用到了动态规划，因为对算法本身也不熟悉，所以记录下来。 题目 查看leetcode题目 描述：有这么一个游戏，提前在[1,n]中选定一个数字，让你猜数字是什么，如果猜错了的话要支付猜错那个数字所代表的的钱，然后告诉你是猜大了还是猜小了，比如在[1,10]中选定了6，一开始猜的是5，那么就要支付5块钱，之后猜的是7，那么就要支付4块钱，直至猜到正确数字6为止。问题是：给定一个n，随机选定一个数字（这个数字是未知的，也不会给出），请问要支付多少钱能够保证获胜？ 我的思路​ 一开始以为是二分查找的问题，但是不然，二分查找并不能保证最快速的找出想要的数字，而且题目要求要支付多少钱能够保证获胜，二分的思想也与题目不符。后话就是我最后知道了解决这类最的问题一般是使用动态规划法，那就学起来呗。 动态规划算法介绍 动态算法的核心就是记住子问题的解 求解方式有两种①自顶向下的备忘录法 ②自底向上法 结合具体例子分析一下两种算法 对于求斐波那契数列来说最常见的方式就是递归法，递归示意图如下： ​ 但是这种直接递归的方式计算了多次f(1)、f(2)、f(3)等结果，如果使用动态递归方法如何解决呢？ 1.自顶向下的备忘录法​ 建立数组Memo，用以保存子问题的解 12345678910111213141516171819202122public static int Fibonacci(int n)&#123; if(n&lt;=0) return n; int []Memo=new int[n+1]; for(int i=0;i&lt;=n;i++) Memo[i]=-1; return fib(n, Memo); &#125; public static int fib(int n,int []Memo) &#123; if(Memo[n]!=-1) return Memo[n]; //如果已经求出了fib（n）的值直接返回，否则将求出的值保存在Memo备忘录中。 if(n&lt;=2) Memo[n]=1; else Memo[n]=fib( n-1,Memo)+fib(n-2,Memo); return Memo[n]; &#125; ​ 上述代码通过数组Memo负责记录f(1)、f(2)….的解，如果数组Memo的某个位置一旦有了!-1的值，这个值直接就确定下来，下次递归可以直接调用。f(n)的值保存在Memo[n]中。 2.自底向上法​ 上述方法实际上还是使用了递归，如果先计算f(1)呢？这就引出了自底向上法，先直接计算子问题，再计算父问题，代码如下： 1234567891011121314public static int fib(int n) &#123; if (n &lt;= 2) &#123; return 1; &#125; int res = 0; int a1 = 1; int a2 = 1; for (int i = 3; i &lt;= n; i++) &#123; res = a1 + a2; a1 = a2; a2 = res; &#125; return res; &#125; ​ 这个也比较好理解，用res记录每次的f(n)，a1当做f(n-2)，a2当做f(n-1)。 动态规划适用的问题：1.最优子结构​ 与贪心算法相反，每一步的求解都是建立在子问题最优的基础上，我们需要做的是考察每个子结构，从中选出最优解。 2.重叠子问题​ 通过数组保存子问题的解，避免通过递归对相同子问题进行多次计算。 动态规划的经典模型1.线性模型2.区间模型3.背包模型总结​ 实质上，在判断一道题目可以用动态规划的思想解决后，要找的就是状态转移方程了（划重点） ​ 说了那么多，最初那道leetcode题怎么解呢？ 12345678910111213141516171819202122public static int getMoneyAmount(int n) &#123; int[][] dp = new int[n + 1][n + 1]; return findDpMax(1, n, dp); &#125; public static int findDpMax(int low, int high, int[][] dp) &#123; if (low &gt;= high) &#123; return 0; &#125; if (dp[low][high] != 0) &#123; return dp[low][high]; &#125; dp[low][high] = Integer.MAX_VALUE; for (int i = low; i &lt;= high; i++) &#123; int left = findDpMax(low, i - 1, dp); int right = findDpMax(i + 1, high, dp); int temp = Math.max(left, right) + i; dp[low][high] = Math.min(temp, dp[low][high]); &#125; System.out.println(low + "," + high + ":" + dp[low][high]); return dp[low][high]; &#125; ​ 通过dp[low][high]二维数组保存在[low, high]区间内所需要的金钱。首先，明确一个规则，当我们选定一个数字i，如果失败只有从左右两个区间[low, i-1]，[i+1, high]中选择，为了保证胜利，我们要选择这两个区间中所花费金额最大的那个。这样状态转移方程就出来了：dp[low][high] = max{dp[low][i-1],dp[i+1][high]} + i，为了保证选择我们依次进行猜测的数字是最合理的，我们需要在[low,high]区间中遍历找到最优的选择方式。这就有了dp[low][high] = Math.min(temp, dp[low][high])以及for循环。 ​ 之前做的硬币问题也可以动过动态规划解决，给你面值1,3,4的硬币，凑成13的最少硬币数是啥？凑成11的呢？凑成6的呢？嘿嘿，贪心算法就解决不了了。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
