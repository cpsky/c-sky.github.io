<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法笔记]]></title>
    <url>%2F2019%2F09%2F01%2F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[笔记1.链表和数组数组没啥可说的 链表没啥可说的练习[1.翻转链表](https://leetcode.com/problems/reverse-linked-list)12345678910111213141516171819class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125;public static ListNode reverseList(ListNode head) &#123; ListNode p = null; ListNode next = null; while (head != null) &#123; next = head.next; head.next = p; p = head; head = next; &#125; return p; &#125; 两个指针，`head`指向链表现在所处的位置，`p`代表翻转链表。 [2.链表两两节点反转](https://leetcode.com/problems/swap-nodes-in-pairs)12345678910111213141516public static ListNode swapPairs(ListNode head) &#123; ListNode cur = new ListNode(-1); cur.next = head; ListNode p = cur; while (cur.next != null &amp;&amp; cur.next.next != null) &#123; ListNode a = cur.next; ListNode b = cur.next.next; cur.next = b; //下列两个等式不能反过来，否则链表会自身循环 a.next = b.next; b.next = a; //不能用cur.next = a.next否则会改变原链表 cur = a; &#125; return p.next; &#125; 这个想了好久好久，最后总结出如果首元节点改变的话，基本都要添加头指针，否则由于首元节点的改变，最后无法回到新的首元节点，我们需要三个指针分别存储cur.next，cur.next.next，以及cur（cur负责对链表进行遍历并进行相应操作）。为了防止链表的自身循环，一定要注意指令的执行顺序。思路很简单：就是在遍历的时候将指针进行翻转，之后cur.next指针后移两位。但是最后一步不能使用cur.next = a.next 或者 cur.next = b.next，因为使用了-&gt;next会使原本头指针发生指向错误（会牵制到p）。但是所幸leetcode结果还是不错： [3.判断链表是否有环](https://leetcode.com/problems/linked-list-cycle) 在leetcode时间允许范围内遍历链表，如果有Null节点，返回true，否则返回false（不推荐） 运用set，判断set中是否存在对应节点 123456789101112public static boolean hasCycle(ListNode head) &#123; Set&lt;ListNode&gt; nodes = new HashSet&lt;&gt;(); while (head != null) &#123; if (nodes.contains(head)) return true; else &#123; nodes.add(head); head = head.next; &#125; &#125; return false; &#125; 快慢指针法，若有环，迟早相遇 1234567891011public static boolean hasCycle(ListNode head) &#123; ListNode fast = head; ListNode slow = head; while (slow != null &amp;&amp; fast != null &amp;&amp; fast.next != null) &#123; slow = slow.next; fast = fast.next.next; if (slow == fast) return true; &#125; return false; &#125; 4.判断链表是否有环ii 运用set，返回相应节点 123456789101112public ListNode detectCycle(ListNode head) &#123; Set&lt;ListNode&gt; nodes = new HashSet&lt;&gt;(); while (head != null) &#123; if (nodes.contains(head)) return head; else &#123; nodes.add(head); head = head.next; &#125; &#125; return null; &#125; 运用快慢指针，但是需要注意一点，两者相遇并不能确保是第一个开始循环的节点，网上的解法很巧妙，但是运用到了数学证明，所以…emmm。 5.翻转链表ii 12345678910111213141516171819202122public static ListNode reverseKGroup(ListNode head, int k) &#123; int n = 0; ListNode cur = head; while(cur != null)&#123; cur = cur.next; n++; &#125; ListNode dmy = new ListNode(0); dmy.next = head; ListNode s = dmy, e = dmy.next; //s: start, e: end for(int i = n; i &gt;= k; i -= k)&#123; for(int j = 1; j &lt; k; j++)&#123; // reverse group ListNode next = e.next; e.next = next.next; next.next = s.next; s.next = next; &#125; s = e; e = s.next; &#125; return dmy.next; &#125; 自己没想出来，看得别人的提交，这个比较好理解，双重循环，里面的循环解决一组翻转，两个指针分别代表翻转开始时的头结点和准备翻转的节点。2.堆栈和队列堆栈队列优先队列（PriorityQueue） 正常入、按照优先级出 实现机制： 1.heap（Binary（大根堆，小根堆），Binomial，Fibonacci） 2.Binary Search Tree（二叉搜索树） 练习1.判断字符串是否合法 1234567891011121314151617181920public static boolean isValid(String s) &#123; Map&lt;Character, Character&gt; mappings = new HashMap&lt;&gt;(); mappings.put('(', ')'); mappings.put('[', ']'); mappings.put('&#123;', '&#125;'); Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (char c : s.toCharArray()) &#123; if (mappings.containsKey(c)) &#123; stack.push(mappings.get(c)); &#125; else if (mappings.containsValue(c)) &#123; if (stack.empty() || stack.pop() != c) &#123; return false; &#125; &#125; &#125; if (stack.empty()) &#123; return true; &#125; return false; &#125; 这是之前做过的一道leetcode的题目，这个是别人的解法，代码很巧妙。运用了栈的思想，先将左括号压入栈，如果碰见右括号，如果该字符串有效的话，应该可以正好匹配栈顶的左括号，否则就无效，当扫描完字符串，栈不为空时，字符串也无效。我想起了这道题的一个变体，给你括号的对数，能输出几种有效的组合呢？123456789101112131415161718//char str = new char[2 * count]public static void Out(int l,int r,char[] str,int count) &#123; if(l &lt; 0 || r &lt; l) return; if(r == 0&amp;&amp;l == 0) &#123; //num++; System.out.println(str);&#125; else &#123; if(l &gt; 0) &#123; str[count] = '('; Out(l -1 ,r,str,count+1); &#125; if(r &gt; l) &#123; str[count] = ')'; Out(l,r-1,str,count+1); &#125; &#125;&#125; 2.利用栈实现队列 1234567891011121314151617181920212223242526272829303132333435363738class MyQueue &#123; private Stack&lt;Integer&gt; s1 = new Stack&lt;&gt;(); private Stack&lt;Integer&gt; s2 = new Stack&lt;&gt;(); private int front; /** Initialize your data structure here. */ public MyQueue() &#123; &#125; /** Push element x to the back of queue. */ public void push(int x) &#123; if (s1.empty()) front = x; s1.push(x); &#125; /** Removes the element from in front of queue and returns that element. */ public int pop() &#123; if (s2.isEmpty()) &#123; while (!s1.isEmpty()) s2.push(s1.pop()); &#125; return s2.pop(); &#125; /** Get the front element. */ public int peek() &#123; if (!s2.isEmpty()) &#123; return s2.peek(); &#125; return front; &#125; /** Returns whether the queue is empty. */ public boolean empty() &#123; return s1.isEmpty() &amp;&amp; s2.isEmpty(); &#125;&#125; 3.实时判断数据流最大元素 小根堆 12345678910111213141516171819202122//优先队列class KthLargest&#123;private int k; private PriorityQueue&lt;Integer&gt; q; public KthLargest(int k, int[] nums) &#123; this.k = k; q = new PriorityQueue&lt;&gt;(k); for (int n: nums) &#123; add(n); &#125; &#125; public int add(int val) &#123; if (q.size() &lt; k) q.offer(val); else if (q.peek() &lt; val) &#123; q.poll(); q.offer(val); &#125; return q.peek(); &#125;&#125; java中PriorityQueue底层数据结构是平衡二叉堆，jdk1.8源码中对该数据结构的介绍： 12345678/** * Priority queue represented as a balanced binary heap: the two * children of queue[n] are queue[2*n+1] and queue[2*(n+1)]. The * priority queue is ordered by comparator, or by the elements' * natural ordering, if comparator is null: For each node n in the * heap and each descendant d of n, n &lt;= d. The element with the * lowest value is in queue[0], assuming the queue is nonempty. */ 大意就是说该堆的实现是由comparator决定的（大根堆、小根堆），如果没有实现该默认的方法则默认为小根堆。4.返回滑动窗口最大值 解法1：利用大根堆（优先队列） 1234567891011121314151617public int[] maxSlidingWindow(int[] nums, int k) &#123; //linkedlist实现了Deque的接口 List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Queue&lt;Integer&gt; p = new PriorityQueue&lt;&gt;(Comparator.reverseOrder()); for (int i = 0; i &lt; nums.length; i++) &#123; if (p.size() &lt; k - 1) &#123; p.add(nums[i]); &#125; else &#123; p.add(nums[i]); res.add(p.peek()); p.remove(nums[i - k + 1]); &#125; &#125; //lambda表达式 int[] end = res.stream().mapToInt(Integer::valueOf).toArray(); return end; &#125; 解法2：利用双端队列 123456789101112131415161718public static int[] maxSlidingWindowii(int[] nums, int k) &#123; LinkedList&lt;Integer&gt; window = new LinkedList&lt;&gt;(); ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; nums.length; i ++) &#123; if (i &gt;= k &amp;&amp; window.getFirst() &lt;= i - k) &#123; window.removeFirst(); &#125; while (window.size() &gt; 0 &amp;&amp; nums[i] &gt;= nums[window.getLast()]) &#123; window.removeLast(); &#125; window.add(i); if (i &gt;= k - 1) &#123; res.add(nums[window.getFirst()]); &#125; &#125; int[] end = res.stream().mapToInt(Integer::valueOf).toArray(); return end; &#125; window记录下标，res记录结果。如果window记录数值的话，不好解决当窗口内元素为k时，窗口向前滑动的情况。3.映射（Map）和集合（Set）映射key: value 形式 HashMap vs TreeMap （哈希表对二叉搜索树） 查询 O(1) O(log&lt;sub&gt;2&lt;/sub&gt;n) 无序 有序 集合HashSet vs TreeSet （哈希表对二叉搜索树） 查询 O(1) O(log&lt;sub&gt;2&lt;/sub&gt;n) 无序 有序 练习1.有效字母异位词 排序 1234567public static boolean isAnagram(String s, String t) &#123; char[] ss = s.toCharArray(); Arrays.sort(ss); char[] tt = t.toCharArray(); Arrays.sort(tt); return Arrays.toString(tt).equals(Arrays.toString(ss)); &#125; Map:计数 123456789101112131415161718192021public static boolean isAnagramii(String s, String t) &#123; HashMap ss = new HashMap&lt;Character,Integer&gt;(); for (char c : s.toCharArray()) &#123; if (ss.containsKey(c)) &#123; Integer tmp = (int)ss.get(c) + 1; ss.put(c,tmp); &#125; else &#123; ss.put(c,1); &#125; &#125; HashMap tt = new HashMap&lt;Character,Integer&gt;(); for (char c : t.toCharArray()) &#123; if (tt.containsKey(c)) &#123; Integer tmp = (int) tt.get(c) + 1; tt.put(c, tmp); &#125; else &#123; tt.put(c, 1); &#125; &#125; return tt.equals(ss); &#125; 改善做法（map计数） 12345678910111213if (s.length() == 0 &amp;&amp; t.length() == 0) return true; if (s.length() != t.length()) return false; int[] sMap = new int[26]; for (char ch: s.toCharArray()) sMap[ch - 'a']++; for (char ch: t.toCharArray()) &#123; if (sMap[ch - 'a'] &gt; 0) &#123; sMap[ch - 'a']--; &#125; else return false; &#125; for (int i = 0; i &lt; 26; i++) &#123; if (sMap[i] != 0) return false; &#125; return true; 通过数组下标记录个数2.两数之和 123456789101112public static int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer, Integer&gt; flag = new HashMap(); for (int i = 0; i &lt; nums.length; i++) &#123; int tmp = target - nums[i]; if (flag.containsKey(tmp)) return new int[]&#123;flag.get(tmp), i&#125;; else &#123; flag.put(nums[i], i); &#125; &#125; return null; &#125; 使用Hashmap记录下标 3.三数之和 使用双重循环，将需要的数字放入set中，如果在遍历过程中发现这个数字就加入到结果集中 1234567891011121314151617181920212223242526272829public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; //使用set为了防止全是0的情况 Set&lt;List&lt;Integer&gt;&gt; res = new HashSet&lt;&gt;(); //排序是为了防止出现重复情况 Arrays.sort(nums); for (int i = 0;i &lt; nums.length - 2;i ++) &#123; //防止重复 if (i &gt;= 1 &amp;&amp; nums[i] == nums[i - 1]) continue; //防止重复，后面大于0的话没必要在进行下去了 if (nums[i] &gt;= 0 &amp;&amp; nums[i + 1] &gt; 0) break; //每一次外层循环要新建一个结果集 Set&lt;Integer&gt; s = new HashSet&lt;&gt;(); for (int j = i + 1;j &lt; nums.length; j ++) &#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); if (!s.contains(nums[j])) &#123; s.add(-(nums[i] + nums[j])); &#125; else &#123; temp.add(nums[i]); temp.add(nums[j]); temp.add(-(nums[i] + nums[j])); res.add(temp); &#125; &#125; &#125; List&lt;List&lt;Integer&gt;&gt; end = new ArrayList&lt;&gt;(res); return end; &#125; 指针法 排序、遍历，如果三个数相加&lt;0 左指针右移，否则右指针左移 1234567891011121314151617181920212223242526public static List&lt;List&lt;Integer&gt;&gt; threeSumii(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(nums); for (int i = 0; i &lt; nums.length - 2; i ++) &#123; if (i &gt;= 1 &amp;&amp; nums[i] == nums[i-1]) continue; int l = i + 1; int r = nums.length - 1; while(l &lt; r)&#123; int sum = nums[i] + nums[r] + nums[l]; if (sum &lt; 0) l++; else if (sum &gt; 0) r--; else &#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); temp.add(nums[i]); temp.add(nums[l]); temp.add(nums[r]); res.add(temp); while (l &lt; r &amp;&amp; nums[l] == nums[l + 1]) l++; while (l &lt; r &amp;&amp; nums[r] == nums[r - 1]) r--; l++; r--; &#125; &#125; &#125; return res; &#125; 4.四数之和 反人类，不搞了 4.树和图树*二叉搜索树* *二叉树遍历*： pre-order：根左右 in-order：左根右 post-order：左右根 图练习1.验证是否是二叉搜索树 中序遍历（递增） 12345678910111213141516public boolean isValidBST(TreeNode root) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); order(root, list); for (int i = 0; i &lt; list.size() - 1; i ++) &#123; if (list.get(i) &gt;= list.get(i+1)) return false; &#125; return true; &#125; public void order (TreeNode root, ArrayList&lt;Integer&gt; res) &#123; if (root != null)&#123; order(root.left, res); res.add(root.val); order(root.right, res); &#125; &#125; 递归判断 最大值最小值 牛皮 1234567public boolean isValid(TreeNode root, Integer min, Integer max) &#123; if (root == null) return true; if (min != null &amp;&amp; root.val &lt;= min) return false; if (max != null &amp;&amp; root.val &gt;= max) return false; return isValid(root.left, min, root.val) &amp;&amp; isValid(root.right,root.val, max); &#125; 2.最近公共祖先 12345678910public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q)&#123; int max = Math.max(p.val, q.val); int min = Math.min(p.val,q.val); if (min &gt; root.val) &#123; return lowestCommonAncestor(root.right, p, q); &#125; else if (max &lt; root.val) &#123; return lowestCommonAncestor(root.left, p, q); &#125; else &#123; return root;&#125;&#125; 这玩意思路很简单，但是做了好久，因为我忘写递归的return了，怎么写都错，我佛了 变体 123456public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null || root == p || root == q) return root; TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right,p,q); return left == null ? right : right == null ? left : root; &#125; 查看左子树和右子树，将结点保存到left、right结点 5.递归和分治递归（Recrusion） 终止条件 递归体（业务逻辑、调用递归函数、做一些收尾工作（不必须）） 分治（Divide&amp;Conquer） 一般不适用于有中间结果、或者重复计算 一般使用递归 步骤： 1.终止条件 2.拆分问题（准备数据） 3.处理数据 4.合并子结果 练习1.求方 时间复杂度为o(n)的做法，由于我用的递归，但是会造成stackflowerror，就是说递归函数会占用太多的栈内存空间，所以递归太深就会报错。 改进版，时间复杂度为(logn)，从中对折。 123456789101112public double myPow(double x, int n) &#123; if(n == 0) return 1; if(n == Integer.MIN_VALUE)&#123; n = n/2; &#125; if(n &lt; 0) &#123; n = -n; x = 1/x; &#125; return (n%2 == 0) ? myPow(x * x, n/2) : x * myPow(x * x, n/2);&#125; 使用mypow(x * x, n/ 2) 而不是mypow(x, n/2) * mypow(x, n/2)的原因是写法简单，因为nk * nk = n2的k次幂。为什么要判断Integer.MIN_VALUE，因为图片： 改进的非递归版本 123456789101112131415161718public double myPow(double x, int n) &#123; if(n == Integer.MIN_VALUE)&#123; n = n/2; &#125; if (n &lt; 0) &#123; x = 1 / x; n = -n; &#125; double pow = 1; while (n &gt; 0) &#123; if ((n &amp; 1) == 1)&#123; pow = pow * x; &#125; x = x * x; n &gt;&gt;= 1; &#125; return pow; &#125; 用的位运算，实质上还是for循环，这样性能应该会好一些。还是运算了n次 2.求众数 暴力 O(n2) map O(n) 排序 O(nlogn) 分治 1234public int majorityElement(int[] nums) &#123; Arrays.sort(nums); return nums[nums.length/2]; &#125; 6.贪心算法 在问题求解时，做出当前最优选择 适用场景：问题可以分成子问题，而且子问题的最优解可以变成全局最优解。 练习1.买卖股票最佳时机 贪心 12345678public int maxProfit(int[] prices) &#123; int profit = 0; for (int i = 0; i &lt; prices.length - 1; i++) &#123; if (prices[i] &lt; prices[i + 1]) profit += (prices[i+1] - prices[i]); &#125; return profit; &#125; 动态规划 7.广度优先、深度优先遍历广度优先： 深度优先：思维类似于栈 练习1.二叉树的层次遍历 BFS 123456789101112131415161718192021222324public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (root == null) return res; //队列 if (root == null) return new ArrayList&lt;&gt;(); LinkedList&lt;TreeNode&gt; tmp = new LinkedList&lt;&gt;(); //HashSet&lt;TreeNode&gt; visted = new HashSet&lt;&gt;(); tmp.add(root); while (!tmp.isEmpty())&#123; ArrayList&lt;Integer&gt; l = new ArrayList&lt;&gt;(); int length = tmp.size(); for (int i = 0; i &lt; length; i++)&#123; TreeNode tn = tmp.removeFirst(); l.add(tn.val); if (tn.left != null) tmp.add(tn.left); if (tn.right != null) tmp.add(tn.right); &#125; res.add(l); &#125; return res; &#125; 通过使用for循环，将每一个层次的树节点输出 DFS 12345678910111213141516public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (root == null) return res; DFS(res, root, 0); return res; &#125; public void DFS(List&lt;List&lt;Integer&gt;&gt; res, TreeNode root, int level) &#123; if (root == null) return; if (res.size() &lt;= level) res.add(new ArrayList&lt;&gt;()); res.get(level).add(root.val); DFS(res, root.left, level + 1); DFS(res, root.right,level + 1); &#125; 注意存入每个节点应该属于的层次，通过深度遍历将值放入所属于的层次中。 2.二叉树的最大高度 DFS 123456789public int maxDepth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int left = maxDepth(root.left); int right = maxDepth(root.right); return Math.max(left, right) + 1; &#125; BFS 1234567891011121314151617public static int maxDepthii(TreeNode root) &#123; int level = 0; if (root == null) return level; LinkedList&lt;TreeNode&gt; tmp = new LinkedList&lt;&gt;(); tmp.add(root); while (!tmp.isEmpty()) &#123; int length = tmp.size(); level++; for (int i = 0; i &lt; length; i++) &#123; TreeNode tn = tmp.removeFirst(); if (tn.right != null) tmp.add(tn.right); if (tn.left != null) tmp.add(tn.left); &#125; &#125; return level; &#125; 3.二叉树的最小高度 DFS 1234567public int minDepth(TreeNode root) &#123; if (root == null) return 0; int left = minDepth(root.left); int right = minDepth(root.right); return (left == 0 || right == 0)? left + right + 1 :Math.min(left,right) + 1; &#125; 这个处理的很巧妙，我的方法就有点low了 1234567public static int DFSii(TreeNode root, int level) &#123; if (root == null) return Integer.MAX_VALUE; if (root.left == null &amp;&amp; root.right == null) return level+1; return Math.min(DFSii(root.left, level + 1), DFSii(root.right, level + 1)); &#125; BFS 12345678910111213141516171819public static int minDepthii(TreeNode root) &#123; int level = 0; if (root == null) return level; LinkedList&lt;TreeNode&gt; tmp = new LinkedList&lt;&gt;(); tmp.add(root); while (!tmp.isEmpty()) &#123; int length = tmp.size(); level++; for (int i = 0; i &lt; length; i++) &#123; TreeNode tn = tmp.removeFirst(); if (tn.right == null &amp;&amp; tn.left == null) return level; if (tn.right != null) tmp.add(tn.right); if (tn.left != null) tmp.add(tn.left); &#125; &#125; return level; &#125; 4.生成括号 123456789101112131415public List generateParenthesis(int n) &#123; ArrayList&lt;String&gt; res = new ArrayList&lt;&gt;(); gen(0,0, n, res, ""); return res; &#125; public void gen(int left, int right, int max, ArrayList&lt;String&gt; res, String s) &#123; if (left == max &amp;&amp; right == max)&#123; res.add(s); return;&#125; if (left &lt; max) gen(left + 1, right, max, res, s + "("); if (right &lt; left &amp;&amp; right &lt; max) gen(left, right + 1, max, res, s + ")"); &#125; 也可通过递归生成所有可能性，然后依次判断，麻烦！ 8.剪枝搜索的常用手段 ，把差的分支去掉(alpha go)练习1.n皇后 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Set&lt;Integer&gt; cols = new HashSet&lt;&gt;(); Set&lt;Integer&gt; pia = new HashSet&lt;&gt;(); Set&lt;Integer&gt; na = new HashSet&lt;&gt;(); List&lt;Integer&gt; cur_state = new ArrayList&lt;&gt;(); DFS(n, 0, cur_state, res, cols, pia, na); List&lt;List&lt;String&gt;&gt; end = new ArrayList&lt;&gt;(); StringBuffer ss = new StringBuffer(); for (int k = 0; k &lt; n; k++)&#123; ss.append("."); &#125; for (int i = 0; i &lt; res.size();i ++) &#123; List&lt;String&gt; tmp = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; res.get(i).size(); j ++) &#123; StringBuffer kk = new StringBuffer(ss); kk.replace(res.get(i).get(j),res.get(i).get(j) + 1, "Q"); tmp.add(kk.toString()); &#125; end.add(tmp); &#125; return end; &#125; public void DFS(int n, int row, List&lt;Integer&gt; cur_state, List&lt;List&lt;Integer&gt;&gt; res, Set&lt;Integer&gt; cols, Set&lt;Integer&gt; pie, Set&lt;Integer&gt; na) &#123; if (row &gt;= n) &#123; if (cur_state.size() == n) &#123; List&lt;Integer&gt; p = new ArrayList&lt;&gt;(); p.addAll(cur_state); System.out.println(cur_state); res.add(p); &#125; return; &#125; for (int i = 0; i &lt; n; i++) &#123; if (cols.contains(i) || pie.contains(i + row) || na.contains(i - row)) &#123; // 不符合条件的 continue; &#125; cols.add(i); pie.add(row + i); na.add(i - row); cur_state.add(i); DFS(n, row + 1, cur_state, res, cols, pie, na); cur_state.remove(cur_state.size() - 1); cols.remove(i); pie.remove(row + i); na.remove(i - row); &#125; &#125; 2.数独问题 12345678910111213141516171819202122232425public boolean isValidSudoku(char[][] board) &#123; boolean flag = true; for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board.length; j++) &#123; flag = isValid(board,i,j,board[i][j]); if (flag == false) return false; &#125; &#125; return true; &#125; public boolean isValid(char[][] board, int row, int col, char c) &#123; for (int i = 0; i &lt; board.length; i++) &#123; if (board[i][col] != '.' &amp;&amp; board[i][col] == c &amp;&amp; row != i) return false; if (board[row][i] != '.' &amp;&amp; board[row][i] == c &amp;&amp; col != i) return false; &#125; int m = (row / 3) * 3; int n = (col / 3) * 3; for (int k = 0; k &lt; 3; k++) &#123; for (int j = 0; j &lt; 3; j++) &#123; if (board[m + k][n + j] != '.' &amp;&amp; board[m + k][n + j] == c &amp;&amp; (m + k) != row &amp;&amp; (n+j) !=col) return false; &#125; &#125; return true; &#125; 2.数独问题ii 123456789101112131415161718192021222324252627282930313233343536373839public void solveSudoku(char[][] board) &#123; solve(board); &#125; public boolean solve(char[][] board) &#123; for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board.length; j++) &#123; if (board[i][j] == '.') &#123; for (char c = '1'; c &lt;= '9'; c++) &#123; if (isValid(board, i, j, c)) &#123; board[i][j] = c; if (solve(board)) return true; else //回退 board[i][j] = '.'; &#125; &#125; return false; &#125; &#125; &#125; return true; &#125; private boolean isValid(char[][] board, int row, int col, char c) &#123; for (int i = 0; i &lt; board.length; i++) &#123; if (board[i][col] != '.' &amp;&amp; board[i][col] == c) return false; if (board[row][i] != '.' &amp;&amp; board[row][i] == c) return false; &#125; int m = (row / 3) * 3; int n = (col / 3) * 3; for (int k = 0; k &lt; 3; k++) &#123; for (int j = 0; j &lt; 3; j++) &#123; if (board[m + k][n + j] != '.' &amp;&amp; board[m + k][n + j] == c) return false; &#125; &#125; return true; &#125; 9.二分查找 有序 数组形式 有界 练习1.平方根 12345678910111213141516171819public int mySqrt(int x) &#123; if (x==1 || x==0) return x; int left = 1; int right = x; int res = 0; //注意等于号 while (left &lt;= right) &#123; int mid = (left + right) / 2; if (mid * mid == x) return mid; else if (mid &gt; x / mid) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; res = mid; &#125; &#125; return res; &#125; 10.字典树(Trie Tree)实际应用统计排序大量字符串，文本词频统计（搜索引擎）基本结构![](https://cxlsky.oss-cn-beijing.aliyuncs.com/blog/img/trie.png?x-oss-process=style/blogimg) 核心思想空间换时间基本性质： 根节点不包含字符，除根节点外每一个节点都只包含一个字符 每个节点所有子节点的字符都不同 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串 练习1.实现一个字典树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class TrieNode &#123; public char val; public boolean isWord; public TrieNode[] children = new TrieNode[26]; public TrieNode() &#123; &#125; public TrieNode(char c) &#123; TrieNode node = new TrieNode(); node.val = c; &#125;&#125; class Trie &#123; private TrieNode root; public Trie() &#123; root = new TrieNode(); root.val = ' '; &#125; /** * Inserts a word into the trie. */ public void insert(String word) &#123; TrieNode ws = root; for (int i = 0; i &lt; word.length(); i++) &#123; char tmp = word.charAt(i); if (ws.children[tmp - 'a'] == null) &#123; ws.children[tmp - 'a'] = new TrieNode(tmp); &#125; ws = ws.children[tmp - 'a']; &#125; ws.isWord = true; &#125; /** * Returns if the word is in the trie. */ public boolean search(String word) &#123; TrieNode ws = root; for (int i = 0; i &lt; word.length(); i++) &#123; char tmp = word.charAt(i); if (ws.children[tmp - 'a'] == null) return false; ws = ws.children[tmp - 'a']; &#125; return ws.isWord; &#125; /** * Returns if there is any word in the trie that starts with the given prefix. */ public boolean startsWith(String prefix) &#123; TrieNode ws = root; for (int i = 0; i &lt; prefix.length(); i++) &#123; char tmp = prefix.charAt(i); if (ws.children[tmp - 'a'] == null) return false; ws = ws.children[tmp - 'a']; &#125; return true; &#125;&#125; 2.单词搜索 12345678910111213141516171819202122232425public List&lt;String&gt; findWords(char[][] board, String[] word) &#123; Set&lt;String&gt; res = new HashSet&lt;&gt;(); for (int o = 0; o &lt; word.length; o++) for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[0].length; j++) &#123; if (exist(board, i, j, word[o], 0)) res.add(word[o]); &#125; &#125; List&lt;String&gt; end = new ArrayList&lt;&gt;(); end.addAll(res); return end; &#125; private boolean exist(char[][] board, int i, int j, String word, int ind) &#123; if (ind == word.length()) return true; if (i &gt; board.length - 1 || i &lt; 0 || j &lt; 0 || j &gt; board[0].length - 1 || board[i][j] != word.charAt(ind)) return false; board[i][j] = '*'; boolean result = exist(board, i - 1, j, word, ind + 1) || exist(board, i, j - 1, word, ind + 1) || exist(board, i, j + 1, word, ind + 1) || exist(board, i + 1, j, word, ind + 1); board[i][j] = word.charAt(ind); return result; &#125; 11.位运算 练习1.二进制数字1的个数 1234567891011public class Solution &#123; // you need to treat n as an unsigned value public int hammingWeight(int n) &#123; int sum = 0; while (n != 0) &#123; n = n &amp; (n - 1); sum++; &#125; return sum; &#125;&#125; 2.是否是2的指数 12345public boolean isPowerOfTwo(int n) &#123; if (n &lt;= 0) return false; n = n &amp; (n - 1); return n == 0; &#125; 3.计算1的个数 1234567public int[] countBits(int num) &#123; int[] arr = new int[num+1]; for (int i = 1; i &lt;= num; i++) &#123; arr[i] = arr[i&amp;(i-1)] + 1; &#125; return arr; &#125; arr 记录1至n中1的个数 得到相关递推公式 4.n皇后 1234567891011121314151617public static int totalNQueens(int n)&#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); dfs(n,res,0,0,0,0); return res.size(); &#125; public static void dfs (int n, List res, int row, int col, int pia, int na) &#123; if (row &gt;= n) &#123; res.add(1); return; &#125; int bits = (~(col | pia | na) &amp; (1 &lt;&lt; n) - 1); while (bits &gt; 0) &#123; int p = bits &amp; (- bits); dfs(n, res, row + 1, col | p, (pia | p) &lt;&lt; 1, (na | p) &gt;&gt; 1); bits = bits &amp; (bits - 1); &#125; &#125; 12.动态规划图 练习1.爬楼梯 123456789101112public int climbStairs(int n) &#123; if (n == 1) return 1; if (n == 2) return 2; int a = 1, b = 2; int sum = 0; for (int i = 2; i &lt; n; i ++) &#123; sum = a + b; a = b; b = sum; &#125; return sum; &#125; 2.三角形的最短路径和 1234567891011public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; int[] res = new int[triangle.size()]; for(int i = 0;i &lt; triangle.size(); i++) res[i] = triangle.get(triangle.size() - 1).get(i); for (int i = triangle.size() - 2; i &gt;= 0; i--) &#123; for (int j = 0; j &lt; triangle.get(i).size(); j++) &#123; res[j] = triangle.get(i).get(j) + Math.min(res[j], res[j + 1]); &#125; &#125; return res[0]; &#125; 3.乘积最大子序列 1234567891011121314151617181920public int maxProduct(int[] nums) &#123; int[][] res = new int[nums.length][2]; // res[][0]当前代表最大值 res[][1]代表当前最小值 for (int i = 0; i &lt; nums.length; i++) &#123; res[i][0] = nums[i]; res[i][1] = nums[i]; &#125; int max = res[0][1]; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] &gt; 0) &#123; res[i][0] = Math.max(nums[i] * res[i - 1][0], res[i][0]); res[i][1] = Math.min(nums[i] * res[i - 1][1], res[i][1]); &#125; else &#123; res[i][0] = Math.max(nums[i] * res[i - 1][1], res[i][0]); res[i][1] = Math.min(nums[i] * res[i - 1][0], res[i][1]); &#125; max = Math.max(max, res[i][0]); &#125; return max; &#125; 4.股票买卖问题 121、122、123 、309、188、714 12 5.最长上升子序列 o(n²) 12345678910111213public static int lengthOfLIS(int[] nums) &#123; int[] dp = new int[nums.length]; int res = 1; for (int i = 0; i &lt; dp.length; i++) dp[i] = 1; for (int i = 1; i &lt; nums.length; i++) &#123; for (int j= 0; j &lt; i; j ++) &#123; if (nums[i] &gt; nums[j]) dp[i] = Math.max(dp[j] + 1, dp[i]); &#125; res = Math.max(res, dp[i]); &#125; return res; &#125; dp[i]代表在i位置的数字时，当前的最长子序列。 O(nlogn) 123456789101112131415public int lengthOfLIS(int[] nums) &#123; int[] dp = new int[nums.length]; int len = 0; for (int num : nums) &#123; int i = Arrays.binarySearch(dp, 0, len, num); if (i &lt; 0) &#123; i = -(i + 1); &#125; dp[i] = num; if (i == len) &#123; len++; &#125; &#125; return len; &#125; 维护一个数组dp ，通过二分查找寻找插入的数（替换掉比其大的最小的数），最后返回长度 6.零钱兑换 12345678910111213public int coinChange(int[] coins, int amount) &#123; int[] dp = new int[amount + 1]; dp[0] = 0; for (int i = 1; i &lt;= amount; i++) dp[i] = amount + 1; for (int i = 1; i &lt;= amount; i++) &#123; for (int coin : coins) &#123; if (i - coin &gt;= 0) dp[i] = Math.min(dp[i - coin] + 1, dp[i]); &#125; &#125; return dp[amount] &gt; amount ? -1 : dp[amount]; &#125; 7.编辑距离 12345678910111213141516public int minDistance(String word1, String word2) &#123; int m = word1.length(); int n = word2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 0; i &lt;= m; i++) dp[i][0] = i; for (int j = 0; j &lt;= n; j++) dp[0][j] = j; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1;j &lt;= n; j++) &#123; if (word1.charAt(i - 1) == word2.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1]; else &#123; dp[i][j] = Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i - 1][j -1])) + 1; &#125; &#125; &#125; return dp[m][n]; &#125; 13.并查集 练习1.岛屿数量 DFS 1234567891011121314151617181920212223if (grid.length == 0) return 0; int res = 0; int m = grid.length; int n = grid[0].length; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (grid[i][j] == '1') &#123; res++; DFS(i, j, grid); &#125; &#125; &#125; return res; &#125; public void DFS(int i, int j, char[][] grid) &#123; if (i &lt; 0 || j &lt; 0 || i &gt; grid.length - 1 || j &gt; grid[0].length - 1 || grid[i][j] == '0') return; grid[i][j] = '0'; DFS(i + 1, j, grid); DFS(i - 1, j, grid); DFS(i, j - 1, grid); DFS(i, j + 1, grid); &#125; 染色法，将附近的小岛全部染色 并查集 1比较麻烦，思路类似 最后数一数祖先数有多少 2.朋友圈 1234567891011121314151617181920212223public int findCircleNum(int[][] grid) &#123; if (grid.length == 0) return 0; int res = 0; int m = grid.length; int n = grid[0].length; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (grid[i][j] == 1) &#123; res++; DFS(i, j, grid); &#125; &#125; &#125; return res; &#125; public void DFS(int i, int j, int[][] grid) &#123; if (i &lt; 0 || j &lt; 0 || i &gt; grid.length - 1 || j &gt; grid[0].length - 1 || grid[i][j] == 0) return; grid[i][j] = 0; for (int m = 0; m &lt; grid.length; m++) DFS(m, j, grid); for (int n = 0; n &lt; grid.length; n++) DFS(i, n, grid); &#125; 与孤岛问题略有不同 14.LRU CacheCache缓存： 记忆 钱包-储物柜 （容量小） 代码模块 LRUCache: 最近最少使用（least recently used） Double LinkedList（双向链表） O(1)查询（最前面） O(1) （修改） 练习1.实现一个LRU Cache 布隆过滤器]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的死锁程序]]></title>
    <url>%2F2019%2F07%2F07%2F%E7%AE%80%E5%8D%95%E7%9A%84%E6%AD%BB%E9%94%81%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[前言​ 在学习工程的同时也要注重基础，几个月前跟着书上写过的一个简单的死锁程序，写在博客中加深记忆 程序123456789101112131415161718192021222324252627282930public class DeadLockDemo &#123; private String A = "A"; private String B = "B"; public static void main(String[] args)&#123; new DeadLockDemo().deadlock(); &#125; private void deadlock() &#123; Thread t1 = new Thread(() -&gt; &#123; synchronized (A) &#123; try &#123; Thread.currentThread().sleep(2000); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; synchronized (B) &#123; System.out.println("1"); &#125; &#125; &#125;); Thread t2 = new Thread(() -&gt; &#123; synchronized (B) &#123; synchronized (A) &#123; System.out.println("2"); &#125; &#125; &#125;); t1.start(); t2.start(); &#125;&#125; ​ 程序中有两个资源字符串A和字符串B，两个线程t1、t2，t1线程先将字符串A锁住，之后让该线程睡眠2s，在睡眠的过程中，线程t2给字符串B加锁，之后想要给字符串A加锁，发现字符串A已经被锁住，等待字符串A的锁被释放，t2线程从醒来，想对字符串B加锁，结果字符串B也被锁住，这样两个线程互相等待对方释放锁，程序无法运行，形成死锁。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot练手项目遇到的那些坑]]></title>
    <url>%2F2019%2F07%2F04%2Fspringboot%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91%2F</url>
    <content type="text"><![CDATA[前言​ 上个月跟着视频做了一个社区项目，学习了spring、springboot、mybatis的用法，框架的使用方法还是蛮好理解的，在这过程中掌握的知识就单独写几篇博客来说明吧，这篇博文主要讲在这个项目中遇到的那些坑 坑 使用的mysql数据库，并且将某些字段设置了默认值，但是通过Mybatis框架插入的时候，还是插入了null值，原来mybatis的insert方法是将所有字段强行全部插入。解决办法：在插入之前给对象赋初始值。 由于在github上的项目不能暴露给别人使用云的key和id，所以我们在application.properties的同级目录下copy一个新的文件叫application-production.properties在里面放置我们生产环境中使用的key和id。此文件只存在于生产环境上，不提交git 我买了阿里云的域名，将域名解析到云主机上，结果竟然没Ping通，找了很多方法也没用，结果过了20分钟自己通了。绑定域名并不复杂，只需要在域名控制台进行dns解析到云主机的弹性ip就可以了 因为项目调用了githun的授权登录接口，所以通过域名访问失败，github开发者应用中修改如下设置就可以了 部署​ 我选择的服务器是centos7，记录一下服务器环境搭建的步骤 要安装的环境： git jdk maven mysql 部署步骤： yum update: 更新安装工具 yum install git git clone (源码地址) yum install maven:自动会装好jdk 参考的博客 重启Mysql:service mysqld restart 查看mysql是否启动·service mysqld status Mysql环境安装好之后用navicat无论如何也连接不上，该授权的授权了，防火墙也都关闭了，查询原因我用的是ucloud的云主机，需要在ucloud控制台中把3306端口开放。 创建数据库，之后在community目录下运行mvn flyway:migrate，集成flyway我之前做过总结。 mvn clean compile package:项目打包，在项目目录下执行 java -jar -Dspring.profiles.active=production target/community-0.0.1-SNAPSHOT.jar 发布项目 注意mysql数据库大小写敏感问题，我修改成太小写不敏感，不然报错 nohup java -jar -Dspring.profiles.active=production target/community-0.0.1-SNAPSHOT.jar &amp;:后台运行 不挂进程]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>springboot</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kmp算法]]></title>
    <url>%2F2019%2F06%2F25%2Fkmp%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言​ 这两天因为一些原因接触了kmp字串符匹配算法，原理很好理解，就是代码实现费了一番周折，看了《数据结构》这本书有关kmp算法的内容，又看了网上给出的一些解决方案，发现还是书上的代码最简洁、最易理解。 一些定义​ s1s2…..sn：主串 ​ t1t2…..tn： 模式串 ​ j ：模式串指针 ​ i ：主串指针 ​ 失配 ：si != tj 原理​ bp字符串的朴素匹配算法：当模式失配时，我们需要把模式指针j移动到0，主串指针i移动到i-j+2处。 ​ kmp算法在此基础上进行改进，对于模式串来说，每个字符对应一个next值（所有next值组成一个next数组），当模式失配时，主串的指针i不变，模式串的指针j移动到next[j]所对应的位置处。优点在于，kmp算法减少了指针的移动次数。 ​ kmp算法的实质：结合下图进行说明 ​ 如上图所示，当失配情况发生时，模式串[1,7]是显然已经匹配完成的。假如1、2位置处的所代表字符与6、7位置所代表的字符相同，当失配之后进行指针移动时，我们可以直接将1,2,移动到6,7原先所在的位置，大大减少了比较次数，主串指针也无需回溯。模式串向右滑动的距离就取决于next[j](此时j==8)。接下来就是如何求解的问题。 实现​ 求模式串向右滑动的距离，换句话说就是当失配发生时，主串i指针所对应的的字符应当直接和模式串第k个字符相比较，k的值就是next[j],j是失配发生时模式串的指针位置。从上面的例子可以看出，求解k所对应的方程式为：t1t2tk-1 = tj-k+1tj-k+2…tj-1 。 ​ 由此引出求next数组定义： next[1] = 0，t1 != si时，下一步进行t1与si+1的比较 k=1时,next[j] = 1，即不存在相同子串，下一步进行t1与si的比较 next[j] = k，(k尽可能大)假如next数组已经求解完成，下面是kmp算法的实现： 1234567891011121314public static int kmp(char[] b, char[] c) &#123; //b是模式串，c是主串 int[] next = getNexts(b); int j = 1,i = 1; while (j &lt; b.length &amp;&amp; i &lt; c.length) &#123; if (j == 0 || b[j - 1] == c[i - 1]) &#123; i++;j++; &#125; else &#123; j = next[j - 1]; &#125; &#125; if (j &gt; b.length - 1) return i - b.length; return -1; &#125; ​ 由于数组是从0开始的，所以涉及的数组的计算都将下标减1。由上文的介绍，代码很容易理解。 求next数组的思想跟kmp算法的思想是相似的，实质上是字符串的自身匹配，只不过主串要从1下标开始，模式串要从0下标开始（仔细想想很好理解，因为需要后面的子串和前面的子串相匹配嘛），代码如下： 1234567891011public static int[] getNexts(char[] b) &#123; int[] next = new int[b.length]; int i = 1,j = 0; next[0] = 0; while (i &lt; b.length) &#123; if (j == 0 || b[i - 1] == b[j - 1]) &#123; i++;j++;next[i - 1] = j; &#125; else &#123;j = next[j - 1];&#125; &#125; return next; &#125; 还有改进的nextval数组，有空再说咯。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>kmp</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集成flyway对数据库进行版本控制]]></title>
    <url>%2F2019%2F06%2F20%2F%E9%9B%86%E6%88%90flyway%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E8%A1%8C%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前言​ flyway官网 是这样描述自己的产品的：flyway是数据库的版本控制工具，它可以使数据库迁移变得简单。对我这种个人学习者的人来说，第二点太重要了，如果我换了个电脑，在github上clone下来源代码，通过执行一条命令，数据库就全部建好了。Springboot如何集成flyway呢？如何使用呢？ 步骤1.在pom文件中添加plugin​ 示例如下： 1234567891011121314151617&lt;plugin&gt; &lt;groupId&gt;org.flywaydb&lt;/groupId&gt; &lt;artifactId&gt;flyway-maven-plugin&lt;/artifactId&gt; &lt;version&gt;5.2.4&lt;/version&gt; &lt;configuration&gt; &lt;url&gt;jdbc:mysql://localhost/community?serverTimezone=GMT&lt;/url&gt; &lt;user&gt;root&lt;/user&gt; &lt;password&gt;*****&lt;/password&gt; &lt;/configuration&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; ​ 根据自身情况对相关联数据库进行配置。 2.创建Migration文件 ​ 步骤很简单，唯一需要注意的点是：文件名必须是Vn(n递增)__(两个下划线)*.sql *里面就是一些描述性语言 文件里面的内容就是你对数据库做出的修改。 3.在终端执行命令 mvn flyway:migrate ​ 万事ok!]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>flyway</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis generator配置]]></title>
    <url>%2F2019%2F06%2F20%2Fmybatis-generator%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[前言​ 每次做完一些配置都会忘，都要回去看博客，mybatis-generator的配置算是比较麻烦的了，但是配好之后用起来很方便，什么mapper，xml、model一键生成，几乎也不用自己写sql语句，爽的飞起，所以必须记录一下。 ​ 官方文档 步骤​ 首先确保你已经在pom文件中添加了mybatis的相关依赖。 1.pom文件中添加plugin，在里面添加数据库相关驱动123456789101112&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/plugin&gt; ​ 我使用的是myssql数据库，所以添加的mysql的驱动 2. 在resources下，创建generatorConfig.xml文件3.配置generatorCofig.xml文件官网示例文件 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;context id="DB2Tables" targetRuntime="MyBatis3"&gt; &lt;plugin type="org.mybatis.generator.plugins.RowBoundsPlugin"&gt;&lt;/plugin&gt; &lt;jdbcConnection driverClass="com.mysql.cj.jdbc.Driver" connectionURL="jdbc:mysql://localhost/community?serverTimezone=GMT" userId="root" password="******"&gt; &lt;property name="nullCatalogMeansCurrent" value="true"/&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver &gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;javaModelGenerator targetPackage="cpsky.community.model" targetProject="src/main/java"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;sqlMapGenerator targetPackage="mapper" targetProject="src/main/resources"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/sqlMapGenerator&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="cpsky.community.mapper" targetProject="src/main/java"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/javaClientGenerator&gt; &lt;table tableName="user" domainObjectName="User" &gt;&lt;/table&gt; &lt;table tableName="question" domainObjectName="Question" &gt;&lt;/table&gt; &lt;table tableName="comment" domainObjectName="Comment"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; &lt;jdbcConnection&gt;填写你的数据库有关信息 &lt;javaModelGenerator&gt;生成java模型（配好路径） &lt;sqlMapperGenerator&gt;生成mapper.xml文件（可以修改生成方式 如注释等） 详见 &lt;javaClientGenerator&gt;生成mapper层 &lt;table&gt;对应数据库的表 4.配置跟springboot相关联官网说明 启动类添加@MapperScan(mapper层路径如com.***.mapper) application.properties添加mybatis.mapper-locations=classpath:mapper/*.xml application.properties添加mybatis.type-aliases-package=com.example.domain.model 5.在终端运行命令 mvn -Dmybatis.generator.overwrite=true mybatis-generator:generate ​ overwrite默认覆盖原先已经存在的文件 6.自定义查询语句​ 因为overwirte=true 会覆盖原文件，所以要新建.xml文件和对应的mapper接口。举个例子： 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="cpsky.community.mapper.CommentExtMapper"&gt; &lt;resultMap id="BaseResultMap" type="cpsky.community.model.Comment"&gt; &lt;!-- WARNING - @mbg.generated This element is automatically generated by MyBatis Generator, do not modify. This element was generated on Sat Jun 08 11:39:52 CST 2019. --&gt; &lt;id column="id" jdbcType="BIGINT" property="id"/&gt; &lt;result column="parent_id" jdbcType="BIGINT" property="parentId"/&gt; &lt;result column="type" jdbcType="INTEGER" property="type"/&gt; &lt;result column="commentator" jdbcType="BIGINT" property="commentator"/&gt; &lt;result column="gmt_create" jdbcType="BIGINT" property="gmtCreate"/&gt; &lt;result column="gmt_modified" jdbcType="BIGINT" property="gmtModified"/&gt; &lt;result column="like_count" jdbcType="BIGINT" property="likeCount"/&gt; &lt;result column="content" jdbcType="VARCHAR" property="content"/&gt; &lt;result column="comment_count" jdbcType="INTEGER" property="commentCount"/&gt; &lt;/resultMap&gt; &lt;update id="incCommentCount" parameterType="cpsky.community.model.Comment"&gt; update COMMENT set comment_count = comment_count + #&#123;commentCount,jdbcType=INTEGER&#125; where id = #&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; ​ 要修改的有namespace ，以及curd语句，语法就是mybatis的语法辣，对应的Mapper接口长这个样子： 123public interface CommentExtMapper &#123; int incCommentCount(Comment comment);&#125;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划算法学习]]></title>
    <url>%2F2019%2F06%2F18%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前言​ 这几天做了一个leetcode的题，用到了动态规划，因为对算法本身也不熟悉，所以记录下来。 题目 查看leetcode题目 描述：有这么一个游戏，提前在[1,n]中选定一个数字，让你猜数字是什么，如果猜错了的话要支付猜错那个数字所代表的的钱，然后告诉你是猜大了还是猜小了，比如在[1,10]中选定了6，一开始猜的是5，那么就要支付5块钱，之后猜的是7，那么就要支付4块钱，直至猜到正确数字6为止。问题是：给定一个n，随机选定一个数字（这个数字是未知的，也不会给出），请问要支付多少钱能够保证获胜？ 我的思路​ 一开始以为是二分查找的问题，但是不然，二分查找并不能保证最快速的找出想要的数字，而且题目要求要支付多少钱能够保证获胜，二分的思想也与题目不符。后话就是我最后知道了解决这类最的问题一般是使用动态规划法，那就学起来呗。 动态规划算法介绍 动态算法的核心就是记住子问题的解 求解方式有两种①自顶向下的备忘录法 ②自底向上法 结合具体例子分析一下两种算法 对于求斐波那契数列来说最常见的方式就是递归法，递归示意图如下： ​ 但是这种直接递归的方式计算了多次f(1)、f(2)、f(3)等结果，如果使用动态递归方法如何解决呢？ 1.自顶向下的备忘录法​ 建立数组Memo，用以保存子问题的解 12345678910111213141516171819202122public static int Fibonacci(int n)&#123; if(n&lt;=0) return n; int []Memo=new int[n+1]; for(int i=0;i&lt;=n;i++) Memo[i]=-1; return fib(n, Memo); &#125; public static int fib(int n,int []Memo) &#123; if(Memo[n]!=-1) return Memo[n]; //如果已经求出了fib（n）的值直接返回，否则将求出的值保存在Memo备忘录中。 if(n&lt;=2) Memo[n]=1; else Memo[n]=fib( n-1,Memo)+fib(n-2,Memo); return Memo[n]; &#125; ​ 上述代码通过数组Memo负责记录f(1)、f(2)….的解，如果数组Memo的某个位置一旦有了!-1的值，这个值直接就确定下来，下次递归可以直接调用。f(n)的值保存在Memo[n]中。 2.自底向上法​ 上述方法实际上还是使用了递归，如果先计算f(1)呢？这就引出了自底向上法，先直接计算子问题，再计算父问题，代码如下： 1234567891011121314public static int fib(int n) &#123; if (n &lt;= 2) &#123; return 1; &#125; int res = 0; int a1 = 1; int a2 = 1; for (int i = 3; i &lt;= n; i++) &#123; res = a1 + a2; a1 = a2; a2 = res; &#125; return res; &#125; ​ 这个也比较好理解，用res记录每次的f(n)，a1当做f(n-2)，a2当做f(n-1)。 动态规划适用的问题：1.最优子结构​ 与贪心算法相反，每一步的求解都是建立在子问题最优的基础上，我们需要做的是考察每个子结构，从中选出最优解。 2.重叠子问题​ 通过数组保存子问题的解，避免通过递归对相同子问题进行多次计算。 动态规划的经典模型1.线性模型2.区间模型3.背包模型总结​ 实质上，在判断一道题目可以用动态规划的思想解决后，要找的就是状态转移方程了（划重点） ​ 说了那么多，最初那道leetcode题怎么解呢？ 12345678910111213141516171819202122public static int getMoneyAmount(int n) &#123; int[][] dp = new int[n + 1][n + 1]; return findDpMax(1, n, dp); &#125; public static int findDpMax(int low, int high, int[][] dp) &#123; if (low &gt;= high) &#123; return 0; &#125; if (dp[low][high] != 0) &#123; return dp[low][high]; &#125; dp[low][high] = Integer.MAX_VALUE; for (int i = low; i &lt;= high; i++) &#123; int left = findDpMax(low, i - 1, dp); int right = findDpMax(i + 1, high, dp); int temp = Math.max(left, right) + i; dp[low][high] = Math.min(temp, dp[low][high]); &#125; System.out.println(low + "," + high + ":" + dp[low][high]); return dp[low][high]; &#125; ​ 通过dp[low][high]二维数组保存在[low, high]区间内所需要的金钱。首先，明确一个规则，当我们选定一个数字i，如果失败只有从左右两个区间[low, i-1]，[i+1, high]中选择，为了保证胜利，我们要选择这两个区间中所花费金额最大的那个。这样状态转移方程就出来了：dp[low][high] = max{dp[low][i-1],dp[i+1][high]} + i，为了保证选择我们依次进行猜测的数字是最合理的，我们需要在[low,high]区间中遍历找到最优的选择方式。这就有了dp[low][high] = Math.min(temp, dp[low][high])以及for循环。 ​ 之前做的硬币问题也可以动过动态规划解决，给你面值1,3,4的硬币，凑成13的最少硬币数是啥？凑成11的呢？凑成6的呢？嘿嘿，贪心算法就解决不了了。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
