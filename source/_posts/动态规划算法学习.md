---
title: 动态规划算法学习
date: 2019-06-18 00:06:36
categories: 算法
tags:
- 动态规划
- leetcode
---

### 前言

​	这几天做了一个leetcode的题，用到了动态规划，因为对算法本身也不熟悉，所以记录下来。

### 题目

- [查看leetcode题目](<https://leetcode.com/problems/guess-number-higher-or-lower-ii/>)

- 描述：有这么一个游戏，提前在[1,n]中选定一个数字，让你猜数字是什么，如果猜错了的话要支付猜错那个数字所代表的的钱，然后告诉你是猜大了还是猜小了，比如在[1,10]中选定了`6`，一开始猜的是5，那么就要支付5块钱，之后猜的是7，那么就要支付4块钱，直至猜到正确数字`6`为止。问题是：给定一个`n`，随机选定一个数字（这个数字是未知的，也不会给出），请问要支付多少钱能够保证获胜？

### 我的思路

​	一开始以为是二分查找的问题，但是不然，二分查找并不能保证最快速的找出想要的数字，而且题目要求要支付多少钱能够`保证`获胜，二分的思想也与题目不符。后话就是我最后知道了解决这类`最`的问题一般是使用动态规划法，那就学起来呗。

### 动态规划算法介绍

动态算法的核心就是记住子问题的解

求解方式有两种①**自顶向下的备忘录法**   ②**自底向上法**

结合具体例子分析一下两种算法

对于求斐波那契数列来说最常见的方式就是递归法，递归示意图如下：

![](http://ptab4lsol.bkt.clouddn.com/fibdiagram.jpg)

​	       计算了多次f(1)、f(2)、f(3)，下面使用两种动态规划的方式解决

#### 1.自顶向下的备忘录法

```java
public static int Fibonacci(int n)
{
        if(n<=0)
            return n;
        int []Memo=new int[n+1];        
        for(int i=0;i<=n;i++)
            Memo[i]=-1;
        return fib(n, Memo);
    }
    public static int fib(int n,int []Memo)
    {

        if(Memo[n]!=-1)
            return Memo[n];
    //如果已经求出了fib（n）的值直接返回，否则将求出的值保存在Memo备忘录中。               
        if(n<=2)
            Memo[n]=1;

        else Memo[n]=fib( n-1,Memo)+fib(n-2,Memo);  

        return Memo[n];
    }
```



#### 2.自底向上法